#!/usr/bin/clisp -ansi -q -Kfull -E iso-8859-1
;;;; -*- mode:lisp; coding:iso-8859-1 -*-
;;;;
;;;; fpm = Front-end Package Management
;;;;
;;;;
;;;; The purpose of this command is to provide a unique user interface
;;;; to all the various and gratuituously distinct package management
;;;; user interfaces.
;;;;
;;;; Supported package managers:
;;;;
;;;; RedHat:   rpm  (Not implemented yet)
;;;; SuSE:     rpm  (Not implemented yet)
;;;; Debian:   apt
;;;; MacOSX:   macport
;;;; Gentoo:   portage
;;;;
;;;; Some commands may be not implemented yet, since I don't
;;;; necessarily know how to do everything with each package
;;;; management system (hence the need of this tool!).
;;;;

(in-package "COMMON-LISP-USER")

;; Clean the packages imported into COMMON-LISP-USER:
(MAPC (LAMBDA (package) (UNUSE-PACKAGE package "COMMON-LISP-USER"))
      (set-difference
       (COPY-SEQ (PACKAGE-USE-LIST "COMMON-LISP-USER"))
       (delete nil (list ;; A list of all the "CL" packages possible:
                    (FIND-PACKAGE "COMMON-LISP")
                    (FIND-PACKAGE "IMAGE-BASED-COMMON-LISP")))))

(load (make-pathname :name "SCRIPT" :type "LISP" :version NIL :case :common
                     :defaults *load-pathname*))
(use-package "SCRIPT")
(setf *program-name* (pname))


(defparameter *program-version* "0.0.2")

(defparameter *usage*
  "
~A~:* version
 
    Report the version of this script and the underlying package system.

~A~:* install     <package-name>

    Install the package named <package-name>.  
    <package-name> may include some specific version according to the 
    underlying package system syntax.


~A~:* update      <package-name>

    Updates the package named <package-name>.  
    <package-name> may include some specific version or version constraint
    according to the underlying package system syntax.


~A~:* remove      <package-name>

    Uninstalls the package named <package-name>.  
    <package-name> may include some specific version or version constraint
    according to the underlying package system syntax.


~A~:* [show] info <package-name>

    Displays information about the package named <package-name>.  
    <package-name> may include some specific version or version constraint
    according to the underlying package system syntax.
    This package may be installed or not.


~A~:* [list] [installed|available|all|not installed] packages [<package-pattern>]

    Lists the packages and versions matching the <package-pattern> or
    all the packages if omited.   The keywords installed, available,
    all or not installed restrict the listing to the correponding
    package.  available and all are synonyms and the default.
    

~A~:* [list] files [in] <package-name>

    Lists the full pathnames of the files in the package named <package-name>.
    <package-name> may include some specific version or version constraint
    according to the underlying package system syntax.
    This package may be installed or not.


~A~:* package [containing] [file] <file-path>

    Lists the package(s) containing the file <file-path>.  If file path
    is not an absolute pathname, then it's taken as a pattern for the
    file paths.


~A~:* search [package] [info] <pattern>

    Lists the packages that have the <pattern> in their package information.


~A~:* [show] dependencies [of] [package] <package-name>

    List the packages on which the package named <package-name> depends.
    <package-name> may include some specific version according to the 
    underlying package system syntax.  
    [installed|newest]



~A~:* [who] depends [on] [package] <package-name>

    List the packages who depend on the package named <package-name>.
    <package-name> may include some specific version according to the 
    underlying package system syntax.  


~A~:* lowly cleanup

    Some package managers need some cleanup.

")

(defun print-usage ()
  (format t *usage* *program-name*))


(defmacro alt (&body body)
  #+ (or) (mapcar (lambda (item)
            (typecase item
              (null)
              (symbol)
              (cons))
            )
          body)
  '(progn))



;;;---------------------------------------------------------------------

(defun print-command (command)
  (format t "~A~%" command) (finish-output)
  command)


(defun shell-quote-argument (argument)
  "Quote ARGUMENT for passing as argument to an inferior shell."
  #+(or MSWINDOWS WIN32)
  ;; Quote using double quotes, but escape any existing quotes in
  ;; the argument with backslashes.
  (let ((result "")
        (start 0)
        (end)
        (match-beginning)
        (match-end))
    (when (or (null (setf match-end (position #\" argument)))
              (< match-end (length argument)))
      (loop
         :while (setf match-beginning (position #\" argument :start start))
         :do (setf end (1+ match-beginning)
                   result (concatenate 'string result (subseq argument start end)
                                       "\\" (subseq argument end (1+ end)))
                   start (1+ end))))
    (concatenate 'string "\"" result (subseq argument start) "\""))
  #-(or MSWINDOWS WIN32)
  (if (equal argument "")
      "''"
      ;; Quote everything except POSIX filename characters.
      ;; This should be safe enough even for really weird shells.
      (let ((result "")
            (start 0)
            (end)
            (match-beginning)
            (match-end))
        (loop
           :while (setf match-end (position-if-not (lambda (ch) (or (alphanumericp ch) (position ch "-_./")))  argument :start start))
           :do (setf end match-end
                     result (concatenate 'string result (subseq argument start end)
                                         "\\" (subseq argument end (1+ end)))
                     start (1+ end)))
        (concatenate 'string result (subseq argument start)))))


(define-condition command-exit-status (error)
  ((command :initform "" :initarg :command :accessor command-exit-status-command)
   (status  :initform 0  :initarg :status  :accessor command-exit-status-status))
  (:report  (lambda (condition stream)
              (format stream "Command ~S exited with status ~D"
                      (command-exit-status-command condition)
                      (command-exit-status-status  condition)))))

(define-condition command-aborted-on-signal (error)
  ((command :initform "" :initarg :command :accessor command-aborted-on-signal-command)
   (signal  :initform 0  :initarg :signal  :accessor command-aborted-on-signal-signal))
  (:report  (lambda (condition stream)
              (format stream "Command ~S was killed by signal ~D"
                      (command-aborted-on-signal-command condition)
                      (command-aborted-on-signal-signal  condition)))))

(defvar *run-output* :terminal)
                                   
(defun run (control-string &rest arguments)
  "Runs the specified shell commands.
Signals an error if they exit with an error status or are killed by a signal."
  (let* ((command (print-command (format nil "{ ~? ; } 2>&1" control-string arguments)))
         (status  (unwind-protect
                       ;; TODO: fork/exec to collect the PID.
                       (ext:run-program "/bin/bash"
                                        :arguments (list "-c" command)
                                        :output *run-output*
                                        :if-output-exists :append)
                    ;; TODO: kill the subprocess
                    (progn))))
    (cond
      ((null   status)
       #|normal exit|#)
      ((not (integerp status))
       (error "Command ~S exited with strange status ~S" command status))
      ((zerop  status)
       #|normal exit|#)
      ((plusp  status)
       (error 'command-exit-status :command command :status status))
      (t
       (error 'command-aborted-on-signal :command command :signal (abs status))))))


;;;---------------------------------------------------------------------


(defun s (command &rest arguments)
  (let ((arguments  (mapcar (lambda (arg) (shell-quote-argument (princ-to-string arg)))
                            arguments)))
   (apply (function run) (format nil "~A~~@{ ~~A~~}" command) arguments)))


(defun e (&rest args)
  (with-output-to-string (out)
    (with-open-stream (in (ext:run-shell-command (format nil "~{~A ~}" args)
                                                 :output :stream :wait nil))
      (loop
         :for line = (read-line in nil nil)
         :while line :do (write-line line out)))))


;;;------------------------------------------------------------
(defclass package-manager ()
  ((name :accessor package-manager-name :initarg :name :type string)))


(defgeneric pm-version (pm))
(defgeneric pm-install (pm package-designator))
(defgeneric pm-update  (pm package-designator))
(defgeneric pm-remove  (pm package-designator))
(defgeneric pm-info    (pm package-designator))

(defgeneric pm-list-packages (pm &key installed all available not-installed
                                 packages pattern))

(defgeneric pm-list-files                    (pm package-designator))
(defgeneric pm-find-package-containing-file  (pm file-path))
(defgeneric pm-find-package-with-info        (pm pattern))
(defgeneric pm-dependencies                  (pm package-designator))
(defgeneric pm-dependants                    (pm package-designator))



;;;------------------------------------------------------------
(defclass rpm (package-manager)
  ())

;;;------------------------------------------------------------
(defclass apt (package-manager)
  ())
  ;; http://www.debian-administration.org/articles/249
;; apt-cache search pound
;; pound - reverse proxy, load balancer and https front-end for web-servers

;; snowball:534$ dpkg -S /bin/cp
;; coreutils: /bin/cp
;; snowball:535$ apt-get source coreutils


(defmethod pm-version ((self apt))
  (s "apt-get --version")) 

(defmethod pm-install ((self apt) package-designator)
  (s "apt-get install" package-designator))

(defmethod pm-update  ((self apt) package-designator)
  (s "apt-get upgrade" package-designator))

(defmethod pm-remove  ((self apt) package-designator)
  (s "apt-get remove" package-designator))

(defmethod pm-info    ((self apt) package-designator)
  (s "dpkg-query --show" package-designator))


(defmethod pm-list-packages ((self apt)
                             &key installed all available not-installed
                             packages pattern)
  (cond
    (packages            (s "dpkg --status"  packages))
    (installed           (s "dpkg --list"    pattern))
    (not-installed       (s "apt-cache search" pattern))
    (t                   (s "dpkg --list " pattern)
                         (s "apt-cache search" pattern))))

(defmethod pm-list-files                    ((self apt) package-designator)
  (s "dpkg --listfiles" package-designator))

(defmethod pm-find-package-containing-file  ((self apt) file-path)
  (format t "# Did you run: #   sudo apt-file update   # ?~%")
  (s "apt-file search" file-path))

(defmethod pm-find-package-with-info        ((self apt) pattern)
  (error "not implemented yet ; how to do that?"))

(defmethod pm-dependencies                  ((self apt) package-designator)
  (s "apt-cache depends" package-designator))

(defmethod pm-dependants                    ((self apt) package-designator)
  (s "apt-cache rdepends" package-designator))



;;;------------------------------------------------------------
(defclass macport (package-manager)
  ())

(defmethod pm-version ((self macport))
  (s "echo quit | port -v | head -1")) ; verbose

(defmethod pm-install ((self macport) package-designator)
  (s "port install" package-designator))

(defmethod pm-update  ((self macport) package-designator)
  (s "port update -u" package-designator))

(defmethod pm-remove  ((self macport) package-designator)
  (s "port uninstall -u" package-designator))

(defmethod pm-info    ((self macport) package-designator)
  (s "port info" package-designator))


(defmethod pm-list-packages ((self macport) &key installed all available
                             not-installed packages pattern)
  (error "not implemented yet")
  (s "port list")
  )

(defmethod pm-list-files                    ((self macport) package-designator)
  (s "port contents" package-designator))

(defmethod pm-find-package-containing-file  ((self macport) file-path)
  (s "port provides" file-path))

(defmethod pm-find-package-with-info        ((self macport) pattern)
  (error "not implemented yet"))

(defmethod pm-dependencies                  ((self macport) package-designator)
  (s "port deps" package-designator))

(defmethod pm-dependants                    ((self macport) package-designator)
  (s "port dependents" package-designator))




;;;------------------------------------------------------------
(defclass portage (package-manager)
  ()
  (:documentation "This is the package manager of gentoo."))


(defmethod pm-version ((self portage))
  (s "emerge --version"))

(defmethod pm-install ((self portage) package-designator)
  (s "emerge" package-designator))

(defmethod pm-update  ((self portage) package-designator)
  (s "emerge --update" package-designator))

(defmethod pm-remove  ((self portage) package-designator)
  (s "emerge --unmerge" package-designator))

(defmethod pm-info    ((self portage) package-designator)
  (s "echo 'I do not know how to get info about packages in gentoo'"))


(defmethod pm-list-packages ((self portage)
                             &key installed all available not-installed
                             packages pattern)
  (cond
    (packages            (s "equery list" packages))
    (installed           (s "equery list    -i -f" pattern))
    (not-installed       (s "equery list -p -I -f" pattern))
    (t                   (s "equery list -p    -f" pattern))))

(defmethod pm-list-files                    ((self portage) package-designator)
  (s "equery files" package-designator))

(defmethod pm-find-package-containing-file  ((self portage) file-path)
  (s "equery belongs" file-path))

(defmethod pm-find-package-with-info        ((self portage) pattern)
  (s "echo 'This is not good.'")
  (s "equery list" pattern))

(defmethod pm-dependencies                  ((self portage) package-designator)
  (s "equery depgraph" package-designator))

(defmethod pm-dependants                    ((self portage) package-designator)
  (s "equery depends" package-designator))




;;;------------------------------------------------------------

;; (defun uname ()
;;   #+clisp
;;   (intern (string-upcase (posix:uname-sysname (posix:uname)))
;;           (load-time-value (find-package "KEYWORD")))
;;   #-clisp
;;   (let ((*package* (find-package "KEYWORD")))
;;     (read-from-string (e "uname"))))


(defun distribution ()
  (cond
    ((ignore-errors (probe-file "/etc/gentoo-release"))     :gentoo)
    ((ignore-errors (probe-file "/etc/SuSE-release"))       :suse)
    ((ignore-errors (probe-file "/etc/mandrake-release"))   :mandrake)
    ((ignore-errors (probe-file "/etc/redhat-release"))     :redhat)
    ((ignore-errors (probe-file "/etc/debian_version"))     :debian)
    (t                                                      :unknown)))


(defun distribution-default-package-management-system (sysname distribution)
  (case sysname
    ((:darwin) 'macport)
    ((:linux)
     (case distribution
       ((:suse :mandrake :redhat) 'rpm)
       ((:gentoo)                 'portage)
       ((:debian)                 'apt)
       (otherwise
        (error "I don't know the package management system used in the ~A distribution of the ~A system."
               distribution sysname))))
    (otherwise
     (error "I don't know the package management system used on the ~A system."
            sysname))))


(defparameter *package-management-system*
  (make-instance
      (distribution-default-package-management-system  (uname) (distribution))))


(defun fpm-operate (key &rest arguments)
  (if (member key '(version install update remove info
                    list-packages list-files
                    find-package-containing-file find-package-with-info
                    dependencies dependants))
      (apply (intern (format nil "PM-~A" key))
             *package-management-system* arguments)
      (error "Invalid key ~A" key)))


(defmacro fpm (key &rest arguments)
  `(fpm-operate (quote ,key) ,@arguments))


;;;------------------------------------------------------------



(define-option ("version" "-v" "--version") ()
  "Report the version of this script and the underlying package system."
  (format t "~A ~A~%" *program-name* *program-version*)
  (fpm version))


(define-option ("install" "-I" "--install") (package-name)
 "Install the package named PACKAGE-NAME.  
PACKAGE-NAME may include some specific version according to the 
underlying package system syntax."
 (fpm install package-name))


(define-option ("update" "-U" "--update") (package-name)
  "Updates the package named PACKAGE-NAME.
PACKAGE-NAME may include some specific version or version constraint
according to the underlying package system syntax."
  (fpm update package-name))


(define-option ("remove" "-R" "--remove") (package-name)
  "Uninstalls the package named PACKAGE-NAME.  
PACKAGE-NAME may include some specific version or version constraint
according to the underlying package system syntax.
"
  (fpm remove package-name))


(define-option ("show-info" "info" "-i" "--show-info" "--info") (package-name)
  ;; [show] info <package-name>
  "Displays information about the package named PACKAGE-NAME.  
PACKAGE-NAME may include some specific version or version constraint
according to the underlying package system syntax.
This package may be installed or not.
"
  (fpm info package-name))


(define-option  ("list-packages" "-p" "--list-packages" "list-package" "packages" "package") (qualifier &optional package-pattern)
  ;; [list] [installed|available|all|not installed] packages [<package-pattern>]
  "Lists the packages and versions matching the PACKAGE-PATTERN or
all the packages if omited.   The keywords installed, available,
all or not installed restrict the listing to the correponding
package.  available and all are synonyms and the default."
  (let ((valid-qualifiers  '(installed available all not-installed)))
    (assert (member qualifier valid-qualifiers
                    :test (function string-equal))
            (qualifier)
            "qualifier should be one of ~{~A~^, ~}"
            valid-qualifiers))
  (fpm list-packages
       (intern (string-upcase qualifier) "KEYWORD") t
       :pattern package-pattern))


(define-option ("list-files" "files" "-l" "--list-files" "--files" "list-file" "file") (package-name)
  ;; [list] files [in] <package-name>
  "Lists the full pathnames of the files in the package named PACKAGE-NAME.
PACKAGE-NAME may include some specific version or version constraint
according to the underlying package system syntax.
This package may be installed or not.
"
  (fpm list-files package-name)) 


(define-option ("package-containing" "package" "-c" "--package-containing") (file-path)
  ;; package [containing] [file] <file-path>
  "Lists the package(s) containing the file FILE-PATH.  If file path
is not an absolute pathname, then it's taken as a pattern for the
file paths."
  (fpm find-package-containing-file file-path))
 


(define-option ("search-package-info" "search-package" "search" 
                "-s"
                "--search-package-info" "--search-package" "--search") (pattern)
  ;; search [package] [info] <pattern>
  "Lists the packages that have the <pattern> in their package information."
  (fpm find-package-with-info pattern))



(define-option ("show-dependencies" "dependencies" "-d" "--show-dependencies" "--dependencies") (package-name)
;; [show] dependencies [of] [package] <package-name>
  "List the packages on which the package named PACKAGE-NAME depends.
PACKAGE-NAME may include some specific version according to the 
underlying package system syntax.  
[installed|newest]
"
  (fpm dependencies package-name))

 

(define-option ("who-depends-on" "depends" "--who-depends-on" "--who-depends" "--depends") (package-name)
  ;; [who] depends [on] [package] <package-name>
  "List the packages who depend on the package named PACKAGE-NAME.
PACKAGE-NAME may include some specific version according to the 
underlying package system syntax.  
"
  (fpm dependants package-name))




;;  "
;; 
;; ~A~:* lowly cleanup
;; 
;;     Some package managers need some cleanup.
;; 
;; "

;; (trace run)
;; (trace s)


(parse-options ext:*args*)

;; #-testing-script
;; (ext:exit (main ext:*args*))

(ext:exit 0)
;;;------------------------------------------------------------


(alt
 (seq (function print-version)  version)
 (seq (function pkg-install)    install     <package-name>)
 (seq (function pkg-update)     update      <package-name>)
 (seq (function pkg-remove)     remove      <package-name>)
 (seq (function pkg-info)       (opt show) info <package-name>)
 (seq (function pkg-list-packages)
      (opt list) (opt (alt installed available all (seq not installed)))
      packages (opt <package-pattern>))
 (seq (function pkg-list-files) (opt list) files (opt in) <package-name>)
 (seq (function pkg-find-file) package (opt containing) (opt file) <file-path>)
 (seq (function pkg-find-info) search (opt package) (opt info) <pattern>)
 (seq (function pkg-dependencies)
      (opt show) dependencies (opt of) (opt package) <package-name>)
 (seq (function pkg-dependants)
      (opt who) depends (opt on) (opt package) <package-name>))

(format t "~&Not implemented yet~%")
;; (ext:exit 1)
