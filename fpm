#!/usr/bin/env clisp -ansi -q -Kfull -E iso-8859-1
;;;; -*- mode:lisp; coding:iso-8859-1 -*-
;;;;
;;;; fpm = Front-end Package Management
;;;; 

(in-package "COMMON-LISP-USER")

;; Clean the packages imported into COMMON-LISP-USER:
(MAPC (LAMBDA (package) (UNUSE-PACKAGE package "COMMON-LISP-USER"))
      (set-difference
       (COPY-SEQ (PACKAGE-USE-LIST "COMMON-LISP-USER"))
       (delete nil (list ;; A list of all the "CL" packages possible:
                    (FIND-PACKAGE "COMMON-LISP")
                    (FIND-PACKAGE "IMAGE-BASED-COMMON-LISP")))))

(load (make-pathname :name "SCRIPT" :type "LISP" :version NIL :case :common
                     :defaults *load-pathname*))
(use-package "SCRIPT")
(setf *program-name* (pname))


(defparameter *program-version* "0.0.2")

(defparameter *usage*
  "
~A~:* version
 
    Report the version of this script and the underlying package system.

~A~:* install     <package-name>

    Install the package named <package-name>.  
    <package-name> may include some specific version according to the 
    underlying package system syntax.


~A~:* update      <package-name>

    Updates the package named <package-name>.  
    <package-name> may include some specific version or version constraint
    according to the underlying package system syntax.


~A~:* remove      <package-name>

    Uninstalls the package named <package-name>.  
    <package-name> may include some specific version or version constraint
    according to the underlying package system syntax.


~A~:* [show] info <package-name>

    Displays information about the package named <package-name>.  
    <package-name> may include some specific version or version constraint
    according to the underlying package system syntax.
    This package may be installed or not.


~A~:* [list] [installed|available|all|not installed] packages [<package-pattern>]

    Lists the packages and versions matching the <package-pattern> or
    all the packages if omited.   The keywords installed, available,
    all or not installed restrict the listing to the correponding
    package.  available and all are synonyms and the default.
    

~A~:* [list] files [in] <package-name>

    Lists the full pathnames of the files in the package named <package-name>.
    <package-name> may include some specific version or version constraint
    according to the underlying package system syntax.
    This package may be installed or not.


~A~:* package [containing] [file] <file-path>

    Lists the package(s) containing the file <file-path>.  If file path
    is not an absolute pathname, then it's taken as a pattern for the
    file paths.


~A~:* search [package] [info] <pattern>

    Lists the packages that have the <pattern> in their package information.


~A~:* [show] dependencies [of] [package] <package-name>

    List the packages on which the package named <package-name> depends.
    <package-name> may include some specific version according to the 
    underlying package system syntax.  
    [installed|newest]



~A~:* [who] depends [on] [package] <package-name>

    List the packages who depend on the package named <package-name>.
    <package-name> may include some specific version according to the 
    underlying package system syntax.  


~A~:* lowly cleanup

    Some package managers need some cleanup.

")

(defun print-usage ()
  (format t *usage* *program-name*))


(defmacro alt (&body body)
  #+ (or) (mapcar (lambda (item)
            (typecase item
              (null)
              (symbol)
              (cons))
            )
          body)
  '(progn))




;;;------------------------------------------------------------
(defclass package-manager ()
  ((name :accessor package-manager-name :initarg :name :type string)))


(defgeneric pm-version (pm))
(defgeneric pm-install (pm package-designator))
(defgeneric pm-update  (pm package-designator))
(defgeneric pm-remove  (pm package-designator))
(defgeneric pm-info    (pm package-designator))

(defgeneric pm-list-packages (pm &key installed all available not-installed
                                 packages pattern))

(defgeneric pm-list-files                    (pm package-designator))
(defgeneric pm-find-package-containing-file  (pm file-path))
(defgeneric pm-find-package-with-info        (pm pattern))
(defgeneric pm-dependencies                  (pm package-designator))
(defgeneric pm-dependants                    (pm package-designator))


(defun s (&rest args)
  (ext:shell (format nil "~{~A ~}" args)))

(defun e (&rest args)
  (with-output-to-string (out)
    (with-open-stream (in (ext:run-shell-command (format nil "~{~A ~}" args)
                                                 :output :stream :wait nil))
      (loop
         :for line = (read-line in nil nil)
         :while line :do (write-line line out)))))

;;;------------------------------------------------------------
(defclass rpm (package-manager)
  ())

;;;------------------------------------------------------------
(defclass apt (package-manager)
  ())
  ;; http://www.debian-administration.org/articles/249
;; apt-cache search pound
;; pound - reverse proxy, load balancer and https front-end for web-servers

;; snowball:534$ dpkg -S /bin/cp
;; coreutils: /bin/cp
;; snowball:535$ apt-get source coreutils



;;;------------------------------------------------------------
(defclass macport (package-manager)
  ())

(defmethod pm-version ((self macport))
  (s "echo quit | port -v | head -1")) ; verbose

(defmethod pm-install ((self macport) package-designator)
  (s "port install" package-designator))

(defmethod pm-update  ((self macport) package-designator)
  (s "port update -u" package-designator))

(defmethod pm-remove  ((self macport) package-designator)
  (s "port uninstall -u" package-designator))

(defmethod pm-info    ((self macport) package-designator)
  (s "port info" package-designator))


(defmethod pm-list-packages ((self macport) &key installed all available
                             not-installed packages pattern)
  (error "not implemented yet")
  (s "port list")
  )

(defmethod pm-list-files                    ((self macport) package-designator)
  (s "port contents" package-designator))

(defmethod pm-find-package-containing-file  ((self macport) file-path)
  (s "port provides" file-path))

(defmethod pm-find-package-with-info        ((self macport) pattern)
  (error "not implemented yet"))

(defmethod pm-dependencies                  ((self macport) package-designator)
  (s "port deps" package-designator))

(defmethod pm-dependants                    ((self macport) package-designator)
  (s "port dependents" package-designator))




;;;------------------------------------------------------------
(defclass portage (package-manager)
  ())


(defmethod pm-version ((self portage))
  (s "emerge --version"))

(defmethod pm-install ((self portage) package-designator)
  (s "emerge" package-designator))

(defmethod pm-update  ((self portage) package-designator)
  (s "emerge --update" package-designator))

(defmethod pm-remove  ((self portage) package-designator)
  (s "emerge --unmerge" package-designator))

(defmethod pm-info    ((self portage) package-designator)
  (s "echo 'I do not know how to get info about packages in gentoo'"))


(defmethod pm-list-packages ((self portage) &key installed all available
                             not-installed packages pattern)
  (error "not implemented yet"))

(defmethod pm-list-files                    ((self portage) package-designator)
  (s "equery files" package-designator))

(defmethod pm-find-package-containing-file  ((self portage) file-path)
  (s "equery belongs" file-path))

(defmethod pm-find-package-with-info        ((self portage) pattern)
  (s "echo 'This is not good.'")
  (s "equery list" pattern))

(defmethod pm-dependencies                  ((self portage) package-designator)
  (s "equery depgraph" package-designator))

(defmethod pm-dependants                    ((self portage) package-designator)
  (s "equery depends" package-designator))




;;;------------------------------------------------------------

;; (defun uname ()
;;   #+clisp
;;   (intern (string-upcase (posix:uname-sysname (posix:uname)))
;;           (load-time-value (find-package "KEYWORD")))
;;   #-clisp
;;   (let ((*package* (find-package "KEYWORD")))
;;     (read-from-string (e "uname"))))


(defun distribution ()
  (cond
    ((ignore-errors (probe-file "/etc/gentoo-release"))     :gentoo)
    ((ignore-errors (probe-file "/etc/SuSE-release"))       :suse)
    ((ignore-errors (probe-file "/etc/mandrake-release"))   :mandrake)
    ((ignore-errors (probe-file "/etc/redhat-release"))     :redhat)
    ((ignore-errors (probe-file "/etc/debian_version"))     :debian)
    (t                                                      :unknown)))


(defun distribution-default-package-management-system (sysname distribution)
  (case sysname
    ((:darwin) 'macport)
    ((:linux)
     (case distribution
       ((:suse :mandrake :redhat) 'rpm)
       ((:gentoo)                 'portage)
       ((:debian)                 'apt)
       (otherwise
        (error "I don't know the package management system used in the ~A distribution of the ~A system."
               distribution sysname))))
    (otherwise
     (error "I don't know the package management system used on the ~A system."
            sysname))))


(defparameter *package-management-system*
  (make-instance
      (distribution-default-package-management-system  (uname) (distribution))))


(defun fpm-operate (key &rest arguments)
  (if (member key '(version install update remove info
                    list-packages list-files
                    find-package-containing-file find-package-with-info
                    dependencies dependants))
      (apply (intern (format nil "PM-~A" key))
             *package-management-system* arguments)
      (error "Invalid key ~A" key)))


(defmacro fpm (key &rest arguments)
  `(fpm-operate (quote ,key) ,@arguments))


;;;------------------------------------------------------------



(define-option ("version" "-v" "--version") ()
  "Report the version of this script and the underlying package system."
  (format t "~A ~A~%" *program-name* *program-version*)
  (fpm version))


(define-option ("install" "-I" "--install") (package-name)
 "Install the package named PACKAGE-NAME.  
PACKAGE-NAME may include some specific version according to the 
underlying package system syntax."
 (fpm install package-name))


(define-option ("update" "-U" "--update") (package-name)
  "Updates the package named PACKAGE-NAME.
PACKAGE-NAME may include some specific version or version constraint
according to the underlying package system syntax."
  (fpm update package-name))


(define-option ("remove" "-R" "--remove") (package-name)
  "Uninstalls the package named PACKAGE-NAME.  
PACKAGE-NAME may include some specific version or version constraint
according to the underlying package system syntax.
"
  (fpm remove package-name))


(define-option ("show-info" "info" "-i" "--show-info" "--info") (package-name)
  ;; [show] info <package-name>
  "Displays information about the package named PACKAGE-NAME.  
PACKAGE-NAME may include some specific version or version constraint
according to the underlying package system syntax.
This package may be installed or not.
"
  (fpm info package-name))


(define-option  ("list-packages" "-p" "--list-packages") (qualifier &optionnal package-pattern)
  ;; [list] [installed|available|all|not installed] packages [<package-pattern>]
  "Lists the packages and versions matching the PACKAGE-PATTERN or
all the packages if omited.   The keywords installed, available,
all or not installed restrict the listing to the correponding
package.  available and all are synonyms and the default."
  (let ((valid-qualifiers  '(installed available all not-installed)))
    (assert (member qualifier valid-qualifiers
                    :test (function string-equalp))
            (qualifier)
            "qualifier should be one of ~{~A~^, ~}"
            valid-qualifiers))
  (fpm list-packages
       (intern (string qualifier) "KEYWORD") t
       :pattern package-pattern))


(define-option ("list-files" "files" "-l" "--list-files" "--files") (package-name)
  ;; [list] files [in] <package-name>
  "Lists the full pathnames of the files in the package named PACKAGE-NAME.
PACKAGE-NAME may include some specific version or version constraint
according to the underlying package system syntax.
This package may be installed or not.
"
  (fpm list-files package-name)) 


(define-option ("package-containing" "package" "-c" "--package-containing") (file-path)
  ;; package [containing] [file] <file-path>
  "Lists the package(s) containing the file FILE-PATH.  If file path
is not an absolute pathname, then it's taken as a pattern for the
file paths."
  (fpm find-package-containing-file file-path))
 


(define-option ("search-package-info" "search-package" "search" 
                "-s"
                "--search-package-info" "--search-package" "--search") (pattern)
  ;; search [package] [info] <pattern>
  "Lists the packages that have the <pattern> in their package information."
  (fpm find-package-with-info pattern))



(define-option ("show-dependencies" "dependencies" "-d" "--show-dependencies" "--dependencies") (package-name)
;; [show] dependencies [of] [package] <package-name>
  "List the packages on which the package named PACKAGE-NAME depends.
PACKAGE-NAME may include some specific version according to the 
underlying package system syntax.  
[installed|newest]
"
  (fpm dependencies package-name))

 

(define-option ("who-depends-on" "depends" "--who-depends-on" "--who-depends" "--depends") (package-name)
  ;; [who] depends [on] [package] <package-name>
  "List the packages who depend on the package named PACKAGE-NAME.
PACKAGE-NAME may include some specific version according to the 
underlying package system syntax.  
"
  (fpm dependants package-name))




 "

~A~:* lowly cleanup

    Some package managers need some cleanup.

"




(parse-options ext:*args*)

;; #-testing-script
;; (ext:exit (main ext:*args*))

;;;------------------------------------------------------------


(alt
 (seq (function print-version)  version)
 (seq (function pkg-install)    install     <package-name>)
 (seq (function pkg-update)     update      <package-name>)
 (seq (function pkg-remove)     remove      <package-name>)
 (seq (function pkg-info)       (opt show) info <package-name>)
 (seq (function pkg-list-packages)
      (opt list) (opt (alt installed available all (seq not installed)))
      packages (opt <package-pattern>))
 (seq (function pkg-list-files) (opt list) files (opt in) <package-name>)
 (seq (function pkg-find-file) package (opt containing) (opt file) <file-path>)
 (seq (function pkg-find-info) search (opt package) (opt info) <pattern>)
 (seq (function pkg-dependencies)
      (opt show) dependencies (opt of) (opt package) <package-name>)
 (seq (function pkg-dependants)
      (opt who) depends (opt on) (opt package) <package-name>))

(format t "~&Not implemented yet~%")
;; (ext:exit 1)
